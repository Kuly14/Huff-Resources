/*
* @author Kuly14
* @notice Contract that shows how to create dynamic arrays in Huff.
* @notice DO NOT USE IN PRODUCTION!
*/

#define function store() nonpayable returns()

#define constant ARRAY_START = FREE_STORAGE_POINTER()

#define macro STORE() = takes(0) returns(0) {
    0x04 calldataload           // [arg_to_store] 
    [ARRAY_START]               // [ARRAY_START_PTR, arg_to_store]
    0x00                        // [0x00, ARRAY_START_PTR, arg_to_store]
    mstore                      // [arg_to_store]

    0x20 0x00                   // [0x20, 0x00, arg_to_store] 
    sha3                        // [hash, arg_to_store]

    [ARRAY_START] sload         // [array_length, hash, arg_to_store]
    dup1                        // [array_length, array_length, hash, arg_to_store]
    0x00                        // [0x00, array_length, array_length, hash, arg_to_store]
    eq                          // [0x00 == array_length, array_length, hash, arg_to_store]
    first jumpi                 // [array_length, hash, arg_to_store]

    dup1                        // [array_length, array_length, hash, arg_to_store]
    0x01                        // [0x01, array_length, array_length, hash, arg_to_store]
    swap1                       // [array_length, 0x01, array_length, hash, arg_to_store]
    sub                         // [array_length - 0x01, array_length, hash, arg_to_store]

    dup3                        // [hash, newStorageSlot, array_length, hash, argToStore]
    add                         // [newStorageSlot, array_length, hash, arg_to_store]
    swap2                       // [hash, array_length, newStorageSlot, arg_to_store]
    pop                         // [array_length, newStorageSlot, arg_to_store] 

    0x01 add                    // [array_length + 1, newStorageSlot, arg_to_store]
    [ARRAY_START]               // [ARRAY_START_PTR, new_array_length, newStorageSlot, arg_to_store]
    sstore                      // [newStorageSlot, arg_to_store]
    sstore                      // []

    first:                      // If the array doesn't yet have any elements we need to init it.
                                // otherwise we would get a underflow when doing array_length - 0x01.
        pop                     // [hash, arg_to_store]
        sstore                  // []
        0x01
        [ARRAY_START]           // [ARRAY_START_PTR, 0x01]
        sstore                  // []

}


#define macro MAIN() = takes(0) returns(0) {
    0x00 calldataload 0xE0 shr

    dup1 __FUNC_SIG(store) eq store jumpi

    store:
        STORE()

    0x00 0x00 
    revert
}